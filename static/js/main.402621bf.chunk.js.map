{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["sleep","ms","Promise","resolve","setTimeout","getRandomInt","max","Math","floor","random","addFilledPixel","filledPixels","parseInt","document","getElementById","textContent","addEmptiedPixel","emptiedPixels","a","pixels","getElementsByClassName","innerHTML","index","length","status","pixelColor","style","backgroundColor","currentColor","color","lenght","missed","emptied","colors","colorId","howMany","id","newColor","makeColors","totalPixels","colorPixels","push","map","item","className","onClick","changeColor","makeGrid","class","pixel","changePixel","App","clearGrid","fillGrid","fillEmptySpots","fillRandom","emptyRandom","fillWithCurrentRandom","fillEmptySpotsRandom","marginLeft","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.402621bf.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nfunction sleep(ms) { // Sleep function that \"sleeps\" given ms amount\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nfunction getRandomInt(max) { // Random function 0-max  ex. (0-255)\r\n  max = max - 1;\r\n  return Math.floor(Math.random() * max);\r\n}\r\n\r\nfunction clearStats() { // Sets stats to zero\r\n  document.getElementById(\"statsFilled\").textContent = \"0\";\r\n  document.getElementById(\"statsEmptied\").textContent = \"0\";\r\n  document.getElementById(\"statsEmpty\").textContent = \"Randomly emptied ones: 0\";\r\n  document.getElementById(\"statsMissed\").textContent = \"Randomly missed ones: 0\";\r\n}\r\n\r\nfunction addFilledPixel() { // Adds 1 to filled pixels\r\n  var filledPixels = parseInt(document.getElementById(\"statsFilled\").textContent);\r\n  document.getElementById(\"statsFilled\").textContent = filledPixels + 1;\r\n}\r\n\r\nfunction addEmptiedPixel() { // Adds 1 to emptied pixels\r\n  var emptiedPixels = parseInt(document.getElementById(\"statsEmptied\").textContent);\r\n  document.getElementById(\"statsEmptied\").textContent = emptiedPixels + 1;\r\n}\r\n\r\nfunction changeColor(id) { // Changes the color with a new color and sets it as active\r\n  var newColor = document.getElementById(id).style.backgroundColor;\r\n  document.getElementById(\"color\").style.backgroundColor = newColor;\r\n}\r\n\r\nfunction changePixel(id) { // Changes the chosen pixels color by the current color\r\n  var pixel = document.getElementById(id);\r\n  var currentColor = document.getElementById(\"color\").style.backgroundColor;\r\n  addFilledPixel();\r\n  pixel.style.backgroundColor = currentColor;\r\n}\r\n\r\nfunction stop() { // Stop function\r\n  document.getElementById(\"status\").innerHTML = \"Status: Stopping\";\r\n}\r\n\r\nasync function clearGrid() { // Clears the whole grid\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  document.getElementById(\"status\").innerHTML = \"Status: Clearing\";\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var pixelColor = pixels[index].style.backgroundColor;\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      if (pixelColor !== \"white\" || pixelColor !== \"\") { // if colour is white skips to next and saves performance\r\n        pixels[index].style.backgroundColor = \"white\";\r\n        addEmptiedPixel();\r\n        //await sleep(0);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nasync function fillGrid() { // Fills the whole grid with chosen color\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var currentColor = document.getElementById(\"color\").style.backgroundColor;\r\n  document.getElementById(\"status\").innerHTML = \"Status: Filling with \" + currentColor;\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var pixelColor = pixels[index].style.backgroundColor;\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      if (pixelColor !== currentColor) { // if colour is chosen color skips to next and saves performance\r\n        pixels[index].style.backgroundColor = currentColor;\r\n        addFilledPixel();\r\n        await sleep(0.5);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nasync function fillEmptySpots() { // Fills all the empty pixels with current color\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var currentColor = document.getElementById(\"color\").style.backgroundColor;\r\n  document.getElementById(\"status\").innerHTML = \"Status: Filling empty pixels with \" + currentColor;\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var color = pixels[index].style.backgroundColor;\r\n    var status = document.getElementById(\"status\").textContent;\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      if (color === \"white\" || color === \"\") { // checks if pixel is empty\r\n        pixels[index].style.backgroundColor = currentColor;\r\n        addFilledPixel();\r\n        await sleep(1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nasync function emptyRandom() { // Empties pixels randomly till none left\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var lenght = pixels.length;\r\n\r\n  var missed = 0; var emptied = 0;\r\n  document.getElementById(\"status\").innerHTML = \"Status: Emptying random\"\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var random = getRandomInt(lenght); // get random number between 0 and pixel lenght\r\n\r\n    var color = pixels[random].style.backgroundColor; // chosen pixels color\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      if (color !== \"white\" || color !== \"\") { // check if pixel is empty\r\n        pixels[random].style.backgroundColor = \"white\";\r\n        emptied++; document.getElementById(\"statsEmpty\").innerHTML = \"Randomly emptied ones: \" + emptied;\r\n        addEmptiedPixel();\r\n        await sleep(1);\r\n      } else { // set index back by one and try again\r\n        index--;\r\n        missed++; document.getElementById(\"statsMissed\").innerHTML = \"Randomly missed ones: \" + missed;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nasync function fillRandom() { // fill grid with random colors\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var colors = document.getElementsByClassName(\"colorBox\");\r\n  document.getElementById(\"status\").innerHTML = \"Status: Random filling\";\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var colorId = \"color\" + getRandomInt(colors.length); // get random number between 0 - colors lenght\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      var color = document.getElementById(colorId).style.backgroundColor;\r\n      pixels[index].style.backgroundColor = color;\r\n      addFilledPixel();\r\n      await sleep(1);\r\n    }\r\n  }\r\n}\r\n\r\nasync function fillWithCurrentRandom() { // Fill grid randomly with current color\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var lenght = pixels.length;\r\n  document.getElementById(\"status\").innerHTML = \"Status: Random filling\";\r\n  var howMany = getRandomInt(lenght); // get random number between 0 - pixels lenght that is max amount of filled pixels\r\n\r\n  for (let index = 0; index < howMany; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var id = getRandomInt(lenght); // get random number between 0 - pixels lenght\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      var currentColor = document.getElementById(\"color\").style.backgroundColor;\r\n      pixels[id].style.backgroundColor = currentColor;\r\n      addFilledPixel();\r\n      await sleep(1);\r\n    }\r\n  }\r\n}\r\n\r\nasync function fillEmptySpotsRandom() { // Fill empty pixels randomly with random colors\r\n  var pixels = document.getElementsByClassName(\"grid\");\r\n  var colors = document.getElementsByClassName(\"colorBox\");\r\n  document.getElementById(\"status\").innerHTML = \"Status: Filling empty pixels randomly\";\r\n\r\n  for (let index = 0; index < pixels.length; index++) {\r\n    var status = document.getElementById(\"status\").textContent;\r\n    var color = pixels[index].style.backgroundColor;\r\n\r\n    if (status !== \"Status: Stopping\") {\r\n      if (color === \"white\" || color === \"\") {\r\n        var id = \"color\" + getRandomInt(colors.length);\r\n        var newColor = document.getElementById(id).style.backgroundColor;\r\n        pixels[index].style.backgroundColor = newColor;\r\n        addFilledPixel();\r\n        await sleep(1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction makeColors() { // Makes color pixels. Colors are stored by names. Full list of 140 names: colors.js\r\n  var colors = [\"Aqua\", \"Beige\", \"Black\", \"Blue\", \"Coral\", \"Crimson\",\r\n    \"DarkBlue\", \"DarkGrey\", \"DarkOrange\", \"DarkSalmon\", \"DarkGreen\", \"DarkRed\",\r\n    \"Grey\", \"Green\", \"White\", \"Yellow\"];\r\n\r\n  var totalPixels = 0;\r\n  var colorPixels = [];\r\n\r\n  for (let index = 0; index < colors.length; index++) {\r\n    var id = \"color\" + totalPixels++;\r\n    var color = colors[index];\r\n    colorPixels.push({ id: id, color: color }); // create and array that has names for values for easier calling\r\n  }\r\n\r\n  return colorPixels.map(item => (\r\n    <div className=\"colorBox\" id={item.id} style={{ backgroundColor: item.color }} onClick={() => changeColor(item.id)} />\r\n  ))\r\n}\r\n\r\nfunction makeGrid() { // Makes the grid and empty pixels\r\n  var pixels = [];\r\n  var pixelAmount = 2100; // how many pixels to create\r\n\r\n  for (let index = 0; index < pixelAmount; index++) {\r\n    pixels.push({ id: index, class: \"grid\" }); // create and array that has names for values for easier calling\r\n  }\r\n\r\n  return pixels.map(item => (\r\n    <div className={item.class} id={item.id} onClick={() => changePixel(item.id)} />\r\n  ))\r\n}\r\n\r\nfunction App() { // \"main\" function. Creates the html and calls different functions\r\n  return (\r\n    <div>\r\n      <h2 id=\"status\">Status:</h2>\r\n      <h1 id=\"title\">\r\n        <h1 id=\"c\">C</h1>\r\n        <h1 id=\"O\">O</h1>\r\n        <h1 id=\"l\">L</h1>\r\n        <h1 id=\"o\">O</h1>\r\n        <h1 id=\"r\">R</h1>\r\n        <h1 id=\"y\">Y</h1>\r\n      </h1>\r\n\r\n      <div className=\"colorContainer\">\r\n        <h2 className=\"colorHeader\">Current color:</h2>\r\n        <div className=\"colorBox\" id=\"color\" />\r\n        <div className=\"colorOuter\">\r\n          {makeColors()}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"gridBox\">\r\n        <button onClick={() => clearGrid()}>Clear pixels</button>\r\n        <button onClick={() => fillGrid()}>Fill all pixels</button>\r\n        <button onClick={() => fillEmptySpots()}>Fill empty pixels</button>\r\n        <button onClick={() => fillRandom()}>Randomize</button>\r\n        <button onClick={() => emptyRandom()}>Empty random</button>\r\n        <button onClick={() => fillWithCurrentRandom()}>Randomize with current</button>\r\n        <button onClick={() => fillEmptySpotsRandom()}>Randomize empty pixels</button>\r\n        <button onClick={() => stop()}>Stop</button>\r\n        <div className=\"gridOuterLayer\">\r\n          {makeGrid()}\r\n        </div>\r\n      </div>\r\n\r\n      <h1>Stats:</h1>\r\n      <h2 className=\"statsFilled\" style={{ marginLeft: \"650px\" }}>Filled pixels:</h2>\r\n      <h2 className=\"statsFilled\" style={{ marginLeft: \"10px\" }} id=\"statsFilled\">0</h2>\r\n      <h2 className=\"statsEmptied\" style={{ marginLeft: \"650px\" }}>Emptied pixels:</h2>\r\n      <h2 className=\"statsEmptied\" style={{ marginLeft: \"10px\" }} id=\"statsEmptied\">0</h2>\r\n      <h2 id=\"statsEmpty\">Randomly emptied ones: 0</h2>\r\n      <h2 id=\"statsMissed\">Randomly missed ones: 0</h2>\r\n      <button style={{ marginLeft: \"700px\" }} onClick={() => clearStats()}>Clear stats</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n    <App />,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}